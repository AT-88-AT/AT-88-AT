<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris VS Simulator</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #f0f0f0; }
        #menu { margin: 20px; }
        #game { display: none; flex-direction: row; justify-content: center; }
        canvas { border: 1px solid black; background-color: white; }
        #opponentCanvas { margin-left: 20px; }
        #controls { margin: 10px; }
        #peerIdDisplay { display: none; margin: 10px; font-weight: bold; }
        #joinInput { display: none; margin: 10px; }
        #scoreLevel { margin: 10px; }
    </style>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>
    <div id="menu">
        <h1>Tetris VS Simulator</h1>
        <p>Gameplay Instructions</p>
        <p>Stack tetrominoes to fill rows and clear lines. In VS mode, clearing multiple lines sends garbage to opponents. Reach higher levels for faster drops and exotic animations.</p>
        <p>Controls</p>
        <ul>
            <li>WASD and ARROW buttons for movement</li>
            <li>Space for hard drop</li>
        </ul>
        <div>
            <label>Difficulty:</label>
            <select id="difficulty">
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
            </select>
        </div>
        <div>
            <label>Music On <input type="checkbox" id="musicOn" checked></label>
            <label>SFX On <input type="checkbox" id="sfxOn" checked></label>
        </div>
        <button onclick="startSingleplayer()">Start Singleplayer</button>
        <button onclick="host2PVS()">Host 2P VS (Online)</button>
        <button onclick="joinVS()">Join VS Game (Online)</button>
        <div>
            <label>Music Volume: <input type="range" id="musicVolume" min="0" max="100" value="50"></label>
        </div>
    </div>
    <div id="game">
        <div>
            <canvas id="tetrisCanvas" width="240" height="480"></canvas>
            <div id="scoreLevel">
                <p>P1 Score: <span id="p1Score">0</span></p>
                <p>Level: <span id="p1Level">1</span></p>
            </div>
        </div>
        <div id="opponentSection" style="display: none;">
            <canvas id="opponentCanvas" width="240" height="480"></canvas>
            <div>
                <p>P2 Score: <span id="p2Score">0</span></p>
                <p>Level: <span id="p2Level">1</span></p>
            </div>
        </div>
    </div>
    <div id="peerIdDisplay">Your Peer ID: <span id="peerId"></span> (Share with opponent)</div>
    <div id="joinInput">
        <label>Enter Host Peer ID: <input type="text" id="peerIdInput"></label>
        <button onclick="connectToPeer()">Connect</button>
    </div>
    <p id="controls">Controls: WASD/Arrows to move, W/Up to rotate, Space to hard drop.</p>

    <script>
        // Core Tetris constants and shapes
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 24;
        const COLORS = ['#000000', '#00FFFF', '#0000FF', '#FFA500', '#FFFF00', '#00FF00', '#800080', '#FF0000', '#808080']; // Added gray for garbage
        const SHAPES = [
            [], // Empty
            [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
            [[0,0,0], [2,2,2], [0,0,2]], // J
            [[0,0,0], [3,3,3], [3,0,0]], // L
            [[0,0], [4,4], [4,4]], // O
            [[0,0,0], [0,5,5], [5,5,0]], // S
            [[0,0,0], [6,6,6], [0,6,0]], // T
            [[0,0,0], [7,7,0], [0,7,7]] // Z
        ];

        // Rotation function
        function rotate(shape) {
            return shape[0].map((_, col) => shape.map(row => row[col]).reverse());
        }

        // Game state variables
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let currentPiece = { type: 0, x: 0, y: 0, rotation: 0 };
        let nextPiece = getRandomPiece();
        let score = 0;
        let level = 1;
        let initLevel = 1;
        let totalLines = 0;
        let dropInterval = 1000;
        let lastDropTime = 0;
        let gameOver = false;
        let isMultiplayer = false;
        let peer = null;
        let conn = null;

        // Opponent state
        let opponentBoard = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let opponentPiece = { type: 0, x: 0, y: 0, rotation: 0 };
        let opponentScore = 0;
        let opponentLevel = 1;
        let opponentGameOver = false;

        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');
        const opponentCanvas = document.getElementById('opponentCanvas');
        const opponentCtx = opponentCanvas.getContext('2d');

        // Get random tetromino
        function getRandomPiece() {
            return Math.floor(Math.random() * 7) + 1;
        }

        // Spawn new piece
        function spawnPiece() {
            const type = nextPiece;
            const piece = { type, x: Math.floor(COLS / 2 - 2), y: 0, rotation: 0 };
            currentPiece = piece;
            nextPiece = getRandomPiece();
            if (collision(piece)) {
                gameOver = true;
                if (isMultiplayer && conn) {
                    conn.send({ type: 'gameOver' });
                    alert('You lose!');
                } else {
                    alert('Game Over!');
                }
            }
        }

        // Collision check
        function collision(piece, dx=0, dy=0, drot=0) {
            const shape = SHAPES[piece.type];
            const rot = (piece.rotation + drot) % 4;
            let rotated = shape;
            for (let i = 0; i < drot; i++) rotated = rotate(rotated);
            for (let y = 0; y < rotated.length; y++) {
                for (let x = 0; x < rotated[y].length; x++) {
                    if (rotated[y][x] && (
                        piece.x + x + dx < 0 ||
                        piece.x + x + dx >= COLS ||
                        piece.y + y + dy >= ROWS ||
                        board[piece.y + y + dy][piece.x + x + dx]
                    )) return true;
                }
            }
            return false;
        }

        // Rotate shape multiple times
        function rotateShape(shape, times) {
            let rotated = shape;
            for (let i = 0; i < times; i++) rotated = rotate(rotated);
            return rotated;
        }

        // Move piece
        function move(dx, dy, rot) {
            if (!collision(currentPiece, dx, dy, rot)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                currentPiece.rotation = (currentPiece.rotation + rot + 4) % 4;
                if (isMultiplayer && conn) sendUpdate();
                return true;
            }
            return false;
        }

        // Hard drop
        function hardDrop() {
            while (move(0, 1, 0)) {}
            dropPiece();
        }

        // Drop piece and check lines
        function dropPiece() {
            const shape = rotateShape(SHAPES[currentPiece.type], currentPiece.rotation);
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        board[currentPiece.y + y][currentPiece.x + x] = currentPiece.type;
                    }
                }
            }
            const lines = clearLines();
            totalLines += lines;
            updateScore(lines);
            if (lines > 1 && isMultiplayer) {
                const garbage = lines - 1;
                if (conn) conn.send({ type: 'garbage', amount: garbage });
            }
            spawnPiece();
            if (isMultiplayer && conn) sendUpdate();
        }

        // Clear full lines
        function clearLines() {
            let lines = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    lines++;
                    y++;
                }
            }
            return lines;
        }

        // Update score and level
        function updateScore(lines) {
            const points = [0, 40, 100, 300, 1200][lines] * level;
            score += points;
            document.getElementById('p1Score').textContent = score;
            level = initLevel + Math.floor(totalLines / 10);
            document.getElementById('p1Level').textContent = level;
            dropInterval = Math.max(100, 1000 - (level - 1) * 50); // Smoother progression
        }

        // Add garbage lines
        function addGarbage(amount) {
            for (let i = 0; i < amount; i++) {
                const row = Array(COLS).fill(8); // Garbage type 8
                row[Math.floor(Math.random() * COLS)] = 0; // Hole
                board.shift();
                board.push(row);
            }
            if (isMultiplayer && conn) sendUpdate();
        }

        // Draw board
        function drawBoard(ctx, b, piece) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    ctx.fillStyle = COLORS[b[y][x]] || '#000000';
                    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            if (piece.type) {
                const shape = rotateShape(SHAPES[piece.type], piece.rotation);
                ctx.fillStyle = COLORS[piece.type];
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            ctx.fillRect((piece.x + x) * BLOCK_SIZE, (piece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    }
                }
            }
        }

        // Game loop
        function gameLoop(time) {
            if (gameOver || opponentGameOver) return;
            if (time - lastDropTime > dropInterval) {
                if (!move(0, 1, 0)) dropPiece();
                lastDropTime = time;
            }
            drawBoard(ctx, board, currentPiece);
            if (isMultiplayer) {
                drawBoard(opponentCtx, opponentBoard, opponentPiece);
            }
            requestAnimationFrame(gameLoop);
        }

        // Key handlers
        document.addEventListener('keydown', e => {
            if (gameOver) return;
            let handled = false;
            if (e.key === 'a' || e.key === 'ArrowLeft') handled = move(-1, 0, 0);
            if (e.key === 'd' || e.key === 'ArrowRight') handled = move(1, 0, 0);
            if (e.key === 's' || e.key === 'ArrowDown') handled = move(0, 1, 0);
            if (e.key === 'w' || e.key === 'ArrowUp') handled = move(0, 0, 1);
            if (e.key === ' ') hardDrop();
            if (handled && isMultiplayer && conn) sendUpdate();
        });

        // Start singleplayer
        function startSingleplayer() {
            initGame(false);
            document.getElementById('opponentSection').style.display = 'none';
            spawnPiece();
            lastDropTime = performance.now();
            gameLoop(performance.now());
        }

        // Host online 2P
        function host2PVS() {
            peer = new Peer();
            peer.on('open', id => {
                document.getElementById('peerId').textContent = id;
                document.getElementById('peerIdDisplay').style.display = 'block';
            });
            peer.on('connection', connection => {
                conn = connection;
                setupConnection();
                initGame(true);
                spawnPiece();
                lastDropTime = performance.now();
                gameLoop(performance.now());
            });
            peer.on('error', err => console.error('Peer error:', err));
        }

        // Join online
        function joinVS() {
            document.getElementById('joinInput').style.display = 'block';
        }

        // Connect to peer
        function connectToPeer() {
            const id = document.getElementById('peerIdInput').value;
            peer = new Peer();
            conn = peer.connect(id);
            setupConnection();
            initGame(true);
            spawnPiece();
            lastDropTime = performance.now();
            gameLoop(performance.now());
            peer.on('error', err => console.error('Peer error:', err));
        }

        // Setup connection events
        function setupConnection() {
            conn.on('data', data => {
                if (data.type === 'update') {
                    opponentBoard = data.board;
                    opponentPiece = data.currentPiece;
                    opponentScore = data.score;
                    opponentLevel = data.level;
                    document.getElementById('p2Score').textContent = opponentScore;
                    document.getElementById('p2Level').textContent = opponentLevel;
                } else if (data.type === 'garbage') {
                    addGarbage(data.amount);
                } else if (data.type === 'gameOver') {
                    opponentGameOver = true;
                    alert('You win!');
                }
            });
            conn.on('close', () => {
                alert('Connection lost. Game over.');
                gameOver = true;
            });
        }

        // Send board update
        function sendUpdate() {
            if (conn) {
                conn.send({
                    type: 'update',
                    board: board,
                    currentPiece: currentPiece,
                    score: score,
                    level: level
                });
            }
        }

        // Init game
        function initGame(multi = false) {
            const diff = document.getElementById('difficulty').value;
            initLevel = {easy: 1, medium: 5, hard: 10}[diff];
            level = initLevel;
            dropInterval = Math.max(100, 1000 - (level - 1) * 50);
            board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
            score = 0;
            totalLines = 0;
            gameOver = false;
            opponentGameOver = false;
            isMultiplayer = multi;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('game').style.display = 'flex';
            document.getElementById('opponentSection').style.display = multi ? 'block' : 'none';
            document.getElementById('p1Score').textContent = 0;
            document.getElementById('p1Level').textContent = level;
            if (multi) {
                document.getElementById('p2Score').textContent = 0;
                document.getElementById('p2Level').textContent = 1;
            }
        }
    </script>
</body>
</html>