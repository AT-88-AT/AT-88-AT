<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Tetris VS Simulator</title>
    <style>
        body { margin: 0; background: black; color: white; font-family: monospace; display: flex; flex-direction: row; align-items: flex-start; justify-content: center; min-height: 100vh; padding-top: 20px; }
        #sidebar { width: 200px; padding: 20px; text-align: left; }
        #main { display: flex; flex-direction: column; align-items: center; }
        #gameArea { display: flex; align-items: flex-start; margin: 20px; position: relative; }
        canvas { border: 1px solid white; background: #111; touch-action: none; }
        #boards { display: flex; flex-direction: row; align-items: flex-start; }
        #rightSide { display: flex; flex-direction: column; align-items: center; }
        #previewCanvas { margin-left: 20px; }
        #controls { margin: 10px; text-align: right; }
        button, select, input { margin: 5px; padding: 10px; background: #333; color: white; border: 1px solid white; cursor: pointer; touch-action: manipulation; }
        #gameOver { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); padding: 20px; display: none; }
        #score, #level { margin: 10px; font-size: 20px; display: inline-block; min-width: 120px; }
        #mobileControls { display: none; margin: 10px; text-align: center; }
        #mobileControls button { padding: 12px; font-size: 18px; }
        #mobileLeft { width: 60px; }
        #mobileRight { width: 60px; }
        #mobileDown { padding: 12px; font-size: 18px; }
        #mobileRotate { padding: 8px; font-size: 12px; }
        #mobileHardDrop { padding: 6px; font-size: 9px; }
        #multiplayerControls { margin: 10px; text-align: center; }
        #gameIdDisplay { margin: 10px; }
        #opponentArea { display: flex; flex-direction: column; align-items: center; margin-left: 20px; }
        #opponentScore { margin: 10px; font-size: 20px; }
        #opponentLevel { margin: 10px; font-size: 20px; }
        #backButton { display: none; margin-top:10px; }
        @media (max-width: 600px) {
            body { flex-direction: column; padding: 10px; overflow-y: scroll; }
            #sidebar { width: auto; text-align: center; }
            #sidebar ul { padding-left: 0; }
            #controls { order: 0; text-align: center; display: flex; flex-direction: column; align-items: center; }
            #gameArea { flex-direction: column; align-items: center; justify-content: center; flex-wrap: nowrap; }
            #previewCanvas { margin: 10px 0 0 0; width: 48px; height: 48px; }
            #tetrisCanvas { width: 200px; height: 400px; }
            #opponentCanvas { width: 37.5px; height: 75px; }
            #score, #level { font-size: 16px; margin: 5px; width: auto; text-align: center; min-width: auto; }
            #mobileControls { display: block; }
            #musicVolume-label { display: none; }
            #startBtn { order: 3; align-self: center; }
            #sfxToggle { margin-right: 10px; }
            #opponentScore, #opponentLevel { font-size: 10px; margin: 2px; }
            body.singleplayer #boards { order: 1; }
            body.singleplayer #rightSide { order: 2; }
            body.singleplayer #opponentArea { order: 3; }
            body.multiplayer #opponentArea { order: 1; }
            body.multiplayer #rightSide { order: 2; }
            body.multiplayer #boards { order: 3; }
        }
        @media (min-width: 601px) {
            #main { flex-direction: column-reverse; }
            #controls { order: 2; }
            #gameArea { order: 1; flex-direction: row; }
        }
    </style>
    <script src="https://unpkg.com/short-unique-id@latest/dist/short-unique-id.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body class="singleplayer">
    <div id="sidebar">
        <h2>Tetris VS Simulator</h2>
        <h3>Gameplay Instructions</h3>
        <p>Stack tetrominoes to fill rows and clear lines. In VS mode, clearing multiple lines sends garbage to opponents. Reach higher levels for faster drops and exotic animations.</p>
        <h3>Controls</h3>
        <ul>
            <li>WASD and ARROW buttons for movement</li>
            <li>Space for hard drop</li>
        </ul>
    </div>
    <div id="main">
        <div id="controls">
            <label>Difficulty:
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                </select>
            </label>
            <button id="musicToggle">Music On</button>
            <button id="sfxToggle">SFX On</button>
            <button id="startBtn">Start Singleplayer</button>
            <button id="pauseBtn" style="display:none;">Pause</button>
            <button id="resumeBtn" style="display:none;">Resume</button>
            <label id="musicVolume-label">Music Volume: <input type="range" id="musicVolume" min="0" max="1" step="0.01" value="0.1"></label>
        </div>
        <div id="multiplayerControls">
            <button id="hostBtn">Host VS Game</button>
            <input id="gameIdInput" placeholder="Enter Game ID to Join">
            <button id="joinBtn">Join VS Game</button>
            <div id="gameIdDisplay" style="display:none;">Your Game ID: <span id="gameId"></span></div>
        </div>
        <div id="gameArea">
            <div id="boards">
                <canvas id="tetrisCanvas" width="200" height="400"></canvas>
            </div>
            <div id="opponentArea" style="display:none;">
                <canvas id="opponentCanvas" width="200" height="400"></canvas>
                <div id="opponentScore">P2 Score: 0</div>
                <div id="opponentLevel">P2 Level: 1</div>
            </div>
            <div id="rightSide">
                <div id="score">P1 Score: 0</div>
                <div id="level">Level: 1</div>
                <canvas id="previewCanvas" width="80" height="80"></canvas>
            </div>
        </div>
        <div id="mobileControls">
            <button id="mobileDown">↓</button>
            <button id="mobileLeft">←</button>
            <button id="mobileRotate">Rotate</button>
            <button id="mobileRight">→</button>
            <button id="mobileHardDrop">Hard Drop</button>
        </div>
    </div>
    <div id="gameOver">
        <h2 id="gameOverTitle">Simulation Over</h2>
        <p>Score: <span id="scoreDisplay">0</span></p>
        <button id="restartBtn">Restart?</button>
    </div>
    <button id="backButton" onclick="location.reload()">Back to Menu</button>
    <script>
        // Core Tetris constants and shapes
        const ROWS = 20, COLS = 10, BLOCK_SIZE = 20, VACANT = '#111';
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(VACANT));
        let opponentBoard = Array.from({length: ROWS}, () => Array(COLS).fill(VACANT));
        let opponentPieceData = null;
        let score = 0;
        let opponentScore = 0;
        let level = 1;
        let opponentLevel = 1;
        let initLevel = 1;
        let totalLines = 0;
        let dropInterval = 1000;
        let lastDropTime = 0;
        let gameOverState = false;
        let opponentGameOver = false;
        let isMultiplayer = false;
        let peer = null;
        let conn = null;
        let paused = true;
        let gameStarted = false;
        let isHost = false;
        let baseInterval = 500;
        let rotateSoundIndex = 0;
        let softDropActive = false;
        let musicOn = true;
        let sfxOn = true;
        let musicVolume = 0.1;
        let lastHorizontalDir = 0;
        let animationSpeed = 1;
        let hardDropping = false;
        let hardDropStart = 0;
        let hardDropDist = 0;
        let hardDropAnimTime = 500;
        let hardDropPressed = false;
        let audioCtx = null;
        let lastType = -1;
        let consecutiveCount = 0;
        const isMobile = window.innerWidth <= 600;

        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');
        const opponentCanvas = document.getElementById('opponentCanvas');
        const opponentCtx = opponentCanvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const backButton = document.getElementById('backButton');

        if (isMobile) {
            previewCanvas.width = 48;
            previewCanvas.height = 48;
            opponentCanvas.width = 37.5;
            opponentCanvas.height = 75;
        }

        const PIECES = [
            [[1,1,1,1]], // I
            [[1,1],[1,1]], // O
            [[0,1,1],[1,1,0]], // S
            [[1,1,0],[0,1,1]], // Z
            [[1,1,1],[0,1,0]], // T
            [[1,1,1],[1,0,0]], // L
            [[1,1,1],[0,0,1]]  // J
        ];
        const HUES = [0, 30, 60, 120, 180, 240, 300];

        const ROTATIONS = PIECES.map(shape => {
            const rots = [];
            let current = shape;
            for (let i = 0; i < 4; i++) {
                rots.push(current);
                current = rotate(current);
            }
            return rots;
        });

        function rotate(shape) {
            return shape[0].map((_, col) => shape.map(row => row[col]).reverse());
        }

        class Piece {
            constructor() {
                let candidateType = Math.floor(Math.random() * PIECES.length);
                let forceDifferent = false;
                if (candidateType === lastType) {
                    let potentialStreak = consecutiveCount + 1;
                    if (potentialStreak >= 3) {
                        forceDifferent = true;
                    } else if (potentialStreak === 2 && Math.random() > 0.3) {
                        forceDifferent = true;
                    }
                }
                if (forceDifferent) {
                    do {
                        candidateType = Math.floor(Math.random() * PIECES.length);
                    } while (candidateType === lastType);
                    consecutiveCount = 0;
                } else {
                    if (candidateType === lastType) {
                        consecutiveCount++;
                    } else {
                        consecutiveCount = 0;
                    }
                }
                this.type = candidateType;
                lastType = this.type;
                this.shape = ROTATIONS[this.type][0];
                this.hue = HUES[this.type];
                const width = this.shape[0].length;
                this.x = Math.floor(COLS / 2 - width / 2);
                this.y = 0;
                this.rotation = 0;
            }
            draw(ctxDraw, offsetX = 0, offsetY = 0, alpha = 1, scale = 1) {
                ctxDraw.globalAlpha = alpha;
                const time = Date.now() / 200 * animationSpeed;
                const hueAmp = Math.min(45, (level - 1) * 4.5);
                const lightAmp = 15 + Math.min(30, (level - 1) * 3);
                const sq = BLOCK_SIZE * scale;
                this.shape.forEach((row, dy) => row.forEach((val, dx) => {
                    if (val) {
                        const hue = this.hue + hueAmp * Math.sin(time / 5 + dx * 1.5 + dy);
                        const light = 50 + lightAmp * Math.sin(time * 0.7 + dx * 2 + dy * 1.2);
                        ctxDraw.fillStyle = `hsl(${hue}, 100%, ${light}%)`;
                        const drawY = (this.y + dy) * sq + offsetY;
                        if (drawY >= 0) {
                            ctxDraw.fillRect((this.x + dx) * sq + offsetX, drawY, sq, sq);
                            ctxDraw.strokeStyle = 'black';
                            ctxDraw.lineWidth = 1;
                            ctxDraw.strokeRect((this.x + dx) * sq + offsetX, drawY, sq, sq);
                        }
                    }
                }));
                ctxDraw.globalAlpha = 1;
            }
            drawPreview() {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                const originalSize = 80;
                const scale = previewCanvas.width / originalSize;
                const sq = BLOCK_SIZE * scale;
                const time = Date.now() / 200;
                const hueAmp = Math.min(45, (level - 1) * 4.5);
                const lightAmp = 15 + Math.min(30, (level - 1) * 3);
                const maxW = Math.max(...this.shape.map(row => row.length));
                const maxH = this.shape.length;
                const offsetX = (4 - maxW) / 2 * sq;
                const offsetY = (4 - maxH) / 2 * sq;
                this.shape.forEach((row, dy) => row.forEach((val, dx) => {
                    if (val) {
                        const hue = this.hue + hueAmp * Math.sin(time / 5 + dx * 1.5 + dy);
                        const light = 50 + lightAmp * Math.sin(time * 0.7 + dx * 2 + dy * 1.2);
                        previewCtx.fillStyle = `hsl(${hue}, 100%, ${light}%)`;
                        previewCtx.fillRect(offsetX + dx * sq, offsetY + dy * sq, sq, sq);
                        previewCtx.strokeStyle = 'black';
                        previewCtx.lineWidth = 1;
                        previewCtx.strokeRect(offsetX + dx * sq, offsetY + dy * sq, sq, sq);
                    }
                }));
            }
            undraw(scale = 1) {
                const sq = BLOCK_SIZE * scale;
                ctx.fillStyle = VACANT;
                this.shape.forEach((row, dy) => row.forEach((val, dx) => {
                    if (val) ctx.fillRect((this.x + dx) * sq, (this.y + dy) * sq, sq, sq);
                }));
            }
            move(dx, dy, scale = 1) {
                this.undraw(scale);
                const oldX = this.x;
                const oldY = this.y;
                this.x += dx;
                this.y += dy;
                if (this.collide(scale)) {
                    this.x = oldX;
                    this.y = oldY;
                    this.draw(ctx, 0, 0, 1, scale);
                    return false;
                }
                this.draw(ctx, 0, 0, 1, scale);
                if (isMultiplayer && conn) sendUpdate();
                return true;
            }
            rotatePiece(scale = 1) {
                this.undraw(scale);
                const oldRotation = this.rotation;
                this.rotation = (this.rotation + 1) % 4;
                this.shape = ROTATIONS[this.type][this.rotation];
                if (this.collide(scale)) {
                    this.rotation = oldRotation;
                    this.shape = ROTATIONS[this.type][this.rotation];
                } else {
                    const rotateFreqs = [600, 700];
                    if (sfxOn) playTone(rotateFreqs[rotateSoundIndex], 50, 0.1);
                    rotateSoundIndex = 1 - rotateSoundIndex;
                    if (isMultiplayer && conn) sendUpdate();
                }
                this.draw(ctx, 0, 0, 1, scale);
            }
            collide(scale = 1) {
                return this.shape.some((row, dy) => row.some((val, dx) => val && (
                    this.x + dx < 0 || this.x + dx >= COLS || this.y + dy >= ROWS ||
                    (this.y + dy >= 0 && board[this.y + dy][this.x + dx] !== VACANT)
                )));
            }
        }

        let currentPiece = null;
        let nextPiece = new Piece();
        let dropStart = Date.now();

        function initAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioCtx.resume();
        }

        function playTone(freq, duration, volume) {
            initAudioContext().then(() => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.value = freq;
                gainNode.gain.value = volume;
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                setTimeout(() => oscillator.stop(), duration);
            });
        }

        function playSilent() {
            initAudioContext().then(() => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.value = 440;
                gainNode.gain.value = 0;
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                setTimeout(() => oscillator.stop(), 1);
            });
        }

        const music = [
            {note: 659, dur: 200}, {note: 523, dur: 200}, {note: 587, dur: 200}, {note: 659, dur: 200},
            {note: 587, dur: 200}, {note: 523, dur: 200}, {note: 494, dur: 200}, {note: 494, dur: 200},
            {note: 523, dur: 200}, {note: 587, dur: 200}, {note: 523, dur: 200}, {note: 494, dur: 200},
            {note: 440, dur: 200}, {note: 440, dur: 200}, {note: 494, dur: 200}, {note: 523, dur: 200},
            {note: 494, dur: 200}, {note: 440, dur: 200}, {note: 392, dur: 400},
            {note: 392, dur: 200}, {note: 440, dur: 200}, {note: 392, dur: 400},
            {note: 659, dur: 200}, {note: 523, dur: 200}, {note: 587, dur: 200}, {note: 659, dur: 200},
            {note: 587, dur: 200}, {note: 523, dur: 200}, {note: 494, dur: 200}, {note: 494, dur: 200},
            {note: 523, dur: 200}, {note: 587, dur: 200}, {note: 523, dur: 200}, {note: 494, dur: 200},
            {note: 440, dur: 200}, {note: 440, dur: 200}, {note: 494, dur: 200}, {note: 523, dur: 200},
            {note: 494, dur: 200}, {note: 440, dur: 200}, {note: 392, dur: 400}
        ];

        let themeIndex = 0;
        let themeTimeout;
        let isThemePlaying = false;
        function playTheme() {
            if (!musicOn || isThemePlaying) return;
            isThemePlaying = true;
            if (themeIndex >= music.length) themeIndex = 0;
            playTone(music[themeIndex].note, music[themeIndex].dur, musicVolume);
            themeIndex++;
            themeTimeout = setTimeout(() => {
                isThemePlaying = false;
                playTheme();
            }, music[themeIndex - 1].dur);
        }

        const resumeAndPlay = () => initAudioContext().then(() => {
            playSilent();
            if (musicOn) playTheme();
        });

        document.addEventListener('touchstart', resumeAndPlay, {once: true});
        document.addEventListener('click', resumeAndPlay, {once: true});

        function drawBoard(ctxDraw, b, scale = 1) {
            ctxDraw.clearRect(0, 0, canvas.width, canvas.height);
            const sq = BLOCK_SIZE * scale;
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    ctxDraw.fillStyle = b[y][x];
                    ctxDraw.fillRect(x * sq, y * sq, sq, sq);
                    ctxDraw.strokeStyle = 'black';
                    ctxDraw.lineWidth = 1;
                    ctxDraw.strokeRect(x * sq, y * sq, sq, sq);
                }
            }
        }

        function drawOpponentPiece(pieceData, scale = 1) {
            opponentCtx.globalAlpha = 1;
            const sq = BLOCK_SIZE * scale;
            const time = Date.now() / 200;
            const hueAmp = Math.min(45, (opponentLevel - 1) * 4.5);
            const lightAmp = 15 + Math.min(30, (opponentLevel - 1) * 3);
            pieceData.shape.forEach((row, dy) => row.forEach((val, dx) => {
                if (val) {
                    const hue = pieceData.hue + hueAmp * Math.sin(time / 5 + dx * 1.5 + dy);
                    const light = 50 + lightAmp * Math.sin(time * 0.7 + dx * 2 + dy * 1.2);
                    opponentCtx.fillStyle = `hsl(${hue}, 100%, ${light}%)`;
                    opponentCtx.fillRect((pieceData.x + dx) * sq, (pieceData.y + dy) * sq, sq, sq);
                    opponentCtx.strokeStyle = 'black';
                    opponentCtx.lineWidth = 1;
                    opponentCtx.strokeRect((pieceData.x + dx) * sq, (pieceData.y + dy) * sq, sq, sq);
                }
            }));
        }

        function updateScoreDisplay() {
            document.getElementById('score').textContent = `P1 Score: ${score}`;
            document.getElementById('opponentScore').textContent = `P2 Score: ${opponentScore}`;
        }

        function updateLevelDisplay() {
            document.getElementById('level').textContent = `Level: ${level}`;
            document.getElementById('opponentLevel').textContent = `P2 Level: ${opponentLevel}`;
        }

        function updateScore(lines) {
            const points = [0, 40, 100, 300, 1200][lines] * level;
            score += points;
            totalLines += lines;
            updateScoreDisplay();
            level = initLevel + Math.floor(totalLines / 10);
            dropInterval = Math.max(100, 1000 - (level - 1) * 50);
            updateLevelDisplay();
        }

        function addGarbage(amount) {
            for (let i = 0; i < amount; i++) {
                const row = Array(COLS).fill(`hsl(0, 0%, 50%)`);
                row[Math.floor(Math.random() * COLS)] = VACANT;
                board.shift();
                board.push(row);
            }
            while (currentPiece.collide()) {
                currentPiece.y--;
                if (currentPiece.y < -2) {
                    gameOverState = true;
                    if (isMultiplayer && conn) conn.send({ type: 'gameOver' });
                    alert('You lose!');
                    backButton.style.display = 'block';
                    break;
                }
            }
            if (isMultiplayer && conn) sendUpdate();
            if (sfxOn) playTone(200, 200, 0.2);
        }

        function gameLoop(time) {
            if (gameOverState || opponentGameOver || paused) {
                backButton.style.display = 'block';
                return;
            }
            if (time - lastDropTime > dropInterval) {
                if (!currentPiece.move(0, 1)) dropPiece();
                lastDropTime = time;
            }
            drawBoard(ctx, board);
            if (isMultiplayer) {
                const oppScale = isMobile ? 0.1875 : 1;
                drawBoard(opponentCtx, opponentBoard, oppScale);
                if (opponentPieceData) drawOpponentPiece(opponentPieceData, oppScale);
            }
            nextPiece.drawPreview();
            requestAnimationFrame(gameLoop);
        }

        function dropPiece() {
            const shape = currentPiece.shape;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        board[currentPiece.y + y][currentPiece.x + x] = `hsl(${currentPiece.hue}, 100%, 50%)`;
                    }
                }
            }
            const lines = clearLines();
            updateScore(lines);
            if (lines > 1 && isMultiplayer) {
                const garbage = lines - 1;
                if (conn) conn.send({ type: 'garbage', amount: garbage });
            }
            spawnPiece();
            if (isMultiplayer && conn) sendUpdate();
            if (sfxOn) playTone(150, 150, 0.2);
            if (lines > 0 && sfxOn) playTone(400 + lines * 100, 200, 0.2);
        }

        function clearLines() {
            let lines = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== VACANT)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(VACANT));
                    lines++;
                    y++;
                }
            }
            return lines;
        }

        function spawnPiece() {
            currentPiece = nextPiece;
            nextPiece = new Piece();
            if (currentPiece.collide()) {
                gameOverState = true;
                if (isMultiplayer && conn) conn.send({ type: 'gameOver' });
                alert(isMultiplayer ? 'You lose!' : 'Game Over!');
                backButton.style.display = 'block';
            }
        }

        function hardDrop() {
            while (currentPiece.move(0, 1)) {}
            dropPiece();
        }

        function togglePause() {
            paused = !paused;
            if (paused) {
                document.getElementById('pauseBtn').style.display = 'none';
                document.getElementById('resumeBtn').style.display = 'inline';
            } else {
                document.getElementById('resumeBtn').style.display = 'none';
                document.getElementById('pauseBtn').style.display = 'inline';
                lastDropTime = performance.now();
                gameLoop(performance.now());
            }
        }

        document.addEventListener('keydown', e => {
            if (gameOverState) return;
            if (e.key === 'Escape') {
                if (!gameStarted) return;
                togglePause();
                return;
            }
            if (paused) return;
            if (e.key.startsWith('Arrow') || ['w', 'a', 's', 'd'].includes(e.key.toLowerCase())) e.preventDefault();
            if (e.key === 'a' || e.key === 'ArrowLeft') {
                lastHorizontalDir = -1;
                currentPiece.move(-1, 0);
            }
            if (e.key === 'd' || e.key === 'ArrowRight') {
                lastHorizontalDir = 1;
                currentPiece.move(1, 0);
            }
            if (e.key === 's' || e.key === 'ArrowDown') {
                softDropActive = true;
                currentPiece.move(0, 1);
            }
            if (e.key === 'w' || e.key === 'ArrowUp') currentPiece.rotatePiece();
            if (e.key === ' ') hardDrop();
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                softDropActive = false;
            }
        });

        let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
        canvas.addEventListener('touchstart', e => {
            if (paused || gameOverState) return;
            e.preventDefault();
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        });

        canvas.addEventListener('touchmove', e => {
            if (paused || gameOverState) return;
            e.preventDefault();
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
        });

        canvas.addEventListener('touchend', e => {
            if (paused || gameOverState) return;
            e.preventDefault();
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 30) currentPiece.move(1, 0);
                else if (deltaX < -30) currentPiece.move(-1, 0);
            } else {
                if (deltaY > 30) hardDrop();
                else if (deltaY < -30) currentPiece.rotatePiece();
            }
        });

        const mobileLeft = document.getElementById('mobileLeft');
        const mobileRight = document.getElementById('mobileRight');
        const mobileDown = document.getElementById('mobileDown');
        const mobileRotate = document.getElementById('mobileRotate');
        const mobileHardDrop = document.getElementById('mobileHardDrop');

        let moveInterval;

        function startMove(dir) {
            handleButtonPress(dir);
            moveInterval = setInterval(() => handleButtonPress(dir), 100);
        }

        function stopMove() {
            clearInterval(moveInterval);
        }

        function handleButtonPress(dir) {
            if (paused || gameOverState) return;
            if (dir === 'left') {
                lastHorizontalDir = -1;
                currentPiece.move(-1, 0);
            }
            if (dir === 'right') {
                lastHorizontalDir = 1;
                currentPiece.move(1, 0);
            }
            if (dir === 'down') {
                softDropActive = true;
                currentPiece.move(0, 1);
            }
            if (dir === 'rotate') currentPiece.rotatePiece();
            if (dir === 'hardDrop') hardDrop();
        }

        mobileLeft.addEventListener('touchstart', e => { e.preventDefault(); startMove('left'); });
        mobileLeft.addEventListener('touchend', stopMove);

        mobileRight.addEventListener('touchstart', e => { e.preventDefault(); startMove('right'); });
        mobileRight.addEventListener('touchend', stopMove);

        mobileDown.addEventListener('touchstart', e => { e.preventDefault(); startMove('down'); });
        mobileDown.addEventListener('touchend', () => { stopMove(); softDropActive = false; });

        mobileRotate.addEventListener('touchstart', e => { e.preventDefault(); handleButtonPress('rotate'); });

        mobileHardDrop.addEventListener('touchstart', e => { e.preventDefault(); if (!hardDropPressed) { hardDropPressed = true; handleButtonPress('hardDrop'); } });
        mobileHardDrop.addEventListener('touchend', () => { hardDropPressed = false; });

        // Start singleplayer
        document.getElementById('startBtn').addEventListener('click', () => {
            initGame(false);
            document.getElementById('opponentArea').style.display = 'none';
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline';
            spawnPiece();
            lastDropTime = performance.now();
            gameLoop(performance.now());
        });

        // Host online 2P
        document.getElementById('hostBtn').addEventListener('click', () => {
            document.getElementById('hostBtn').style.display = 'none';
            document.getElementById('joinBtn').style.display = 'none';
            document.getElementById('gameIdInput').style.display = 'none';
            setupMultiplayer(true);
        });

        // Join online
        document.getElementById('joinBtn').addEventListener('click', () => {
            const id = document.getElementById('gameIdInput').value.toUpperCase();
            if (id) {
                document.getElementById('hostBtn').style.display = 'none';
                document.getElementById('joinBtn').style.display = 'none';
                document.getElementById('gameIdInput').style.display = 'none';
                setupMultiplayer(false, id);
            }
        });

        function setupMultiplayer(host, joinId = null) {
            isHost = host;
            if (host) {
                const shortId = new ShortUniqueId({ length: 4 }).rnd().toUpperCase();
                peer = new Peer(shortId, {
                    host: '0.peerjs.com',
                    port: 443,
                    secure: true,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' }
                        ]
                    }
                });
                peer.on('open', id => {
                    document.getElementById('gameId').textContent = id;
                    document.getElementById('gameIdDisplay').style.display = 'block';
                });
                peer.on('connection', connection => {
                    conn = connection;
                    setupConnection();
                    conn.on('open', () => {
                        initGame(true);
                        spawnPiece();
                        sendUpdate();
                        lastDropTime = performance.now();
                        gameLoop(performance.now());
                    });
                });
                peer.on('error', err => console.error('Peer error:', err));
            } else {
                peer = new Peer({
                    host: '0.peerjs.com',
                    port: 443,
                    secure: true,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' }
                        ]
                    }
                });
                peer.on('open', () => {
                    if (joinId) {
                        conn = peer.connect(joinId);
                        setupConnection();
                        conn.on('open', () => {
                            initGame(true);
                            spawnPiece();
                            sendUpdate();
                            lastDropTime = performance.now();
                            gameLoop(performance.now());
                        });
                    }
                });
                peer.on('error', err => console.error('Peer error:', err));
            }
        }

        // Setup connection events
        function setupConnection() {
            conn.on('data', data => {
                if (data.type === 'update') {
                    opponentBoard = data.board;
                    opponentPieceData = data.currentPiece;
                    opponentScore = data.score;
                    opponentLevel = data.level;
                    document.getElementById('opponentScore').textContent = `P2 Score: ${opponentScore}`;
                    document.getElementById('opponentLevel').textContent = `P2 Level: ${opponentLevel}`;
                } else if (data.type === 'garbage') {
                    addGarbage(data.amount);
                } else if (data.type === 'gameOver') {
                    opponentGameOver = true;
                    alert('You win!');
                    backButton.style.display = 'block';
                }
            });
            conn.on('close', () => {
                alert('Connection lost. Game over.');
                gameOverState = true;
                backButton.style.display = 'block';
            });
        }

        // Send board update
        function sendUpdate() {
            if (conn) {
                conn.send({
                    type: 'update',
                    board: board,
                    currentPiece: {x: currentPiece.x, y: currentPiece.y, shape: currentPiece.shape, hue: currentPiece.hue, rotation: currentPiece.rotation},
                    score: score,
                    level: level
                });
            }
        }

        // Init game
        function initGame(multi = false) {
            const diff = document.getElementById('difficulty').value;
            initLevel = {easy: 1, medium: 5, hard: 10}[diff];
            level = initLevel;
            dropInterval = Math.max(100, 1000 - (level - 1) * 50);
            board = Array.from({length: ROWS}, () => Array(COLS).fill(VACANT));
            score = 0;
            totalLines = 0;
            gameOverState = false;
            opponentGameOver = false;
            isMultiplayer = multi;
            document.getElementById('controls').style.display = 'none';
            document.getElementById('multiplayerControls').style.display = 'none';
            document.getElementById('gameArea').style.display = 'flex';
            document.getElementById('opponentArea').style.display = multi ? 'flex' : 'none';
            updateScoreDisplay();
            updateLevelDisplay();
            backButton.style.display = 'none';
            paused = false;
            gameStarted = true;
            initAudioContext().then(() => {
                playSilent();
                if (musicOn) playTheme();
            });
        }

        document.getElementById('musicToggle').addEventListener('click', () => {
            musicOn = !musicOn;
            document.getElementById('musicToggle').textContent = `Music ${musicOn ? 'On' : 'Off'}`;
            if (musicOn) {
                clearTimeout(themeTimeout);
                themeIndex = 0;
                initAudioContext().then(playTheme);
            } else {
                clearTimeout(themeTimeout);
                isThemePlaying = false;
            }
        });

        document.getElementById('sfxToggle').addEventListener('click', () => {
            sfxOn = !sfxOn;
            document.getElementById('sfxToggle').textContent = `SFX ${sfxOn ? 'On' : 'Off'}`;
        });

        document.getElementById('musicVolume').addEventListener('input', e => {
            musicVolume = parseFloat(e.target.value);
        });

        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('resumeBtn').addEventListener('click', togglePause);
    </script>
</body>
</html>